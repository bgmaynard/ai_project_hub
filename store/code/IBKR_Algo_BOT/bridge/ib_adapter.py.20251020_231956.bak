import os
import sys
import time
import socket
import logging
from dataclasses import dataclass
from typing import Optional, Dict, Any
from pathlib import Path

# Ensure project root import works on Windows
project_root = Path(__file__).resolve().parents[3]
if str(project_root) not in sys.path:
    sys.path.insert(0, str(project_root))

# Environment
try:
    from dotenv import load_dotenv
    load_dotenv(project_root / ".env")
except Exception:
    pass

# ib_insync (required)
try:
    from ib_insync import IB, Stock, MarketOrder, LimitOrder
    _IB_OK = True
except Exception as e:
    IB = None  # type: ignore
    _IB_OK = False

logging.basicConfig(level=logging.INFO)
log = logging.getLogger("ib_adapter")

class ConnState:
    DISCONNECTED = "DISCONNECTED"
    CONNECTING = "CONNECTING"
    CONNECTED = "CONNECTED"
    DEGRADED = "DEGRADED"
    FAILED = "FAILED"

@dataclass
class IBConfig:
    host: str = os.getenv("TWS_HOST", "127.0.0.1")
    port: int = int(os.getenv("TWS_PORT", "7497"))   # TWS default (NOT Gateway)
    client_id: int = int(os.getenv("TWS_CLIENT_ID", "6001"))
    read_only: bool = os.getenv("IB_READ_ONLY", "1") not in ("0", "false", "False")
    connect_timeout: float = float(os.getenv("IB_CONNECT_TIMEOUT_SEC", "30"))
    max_retries: int = int(os.getenv("IB_MAX_RETRIES", "4"))
    retry_delay: float = float(os.getenv("IB_RETRY_DELAY_SEC", "3"))

class IBAdapter:
    def __init__(self, cfg: Optional[IBConfig] = None):
        self.cfg = cfg or IBConfig()
        self.ib: Optional["IB"] = None
        self.state = ConnState.DISCONNECTED
        self.connected = False
        self.last_error: Optional[str] = None
        self.current_client_id = self.cfg.client_id
        self.attempts = 0

    def _socket_open(self) -> bool:
        try:
            with socket.create_connection((self.cfg.host, self.cfg.port), timeout=2):
                return True
        except Exception:
            return False

    def connect(self) -> bool:
        if not _IB_OK:
            self.last_error = "ib_insync not installed"
            self.state = ConnState.FAILED
            return False
        if not self._socket_open():
            self.last_error = f"TWS not listening on {self.cfg.host}:{self.cfg.port}"
            self.state = ConnState.FAILED
            log.error(self.last_error)
            return False

        self.state = ConnState.CONNECTING
        self.ib = IB()

        for i in range(self.cfg.max_retries):
            cid = self.cfg.client_id + i
            self.attempts += 1
            log.info(f"IBAdapter: trying clientId {cid}")
            try:
                # sync connect with timeout window
                self.ib.connect(self.cfg.host, self.cfg.port, clientId=cid, timeout=self.cfg.connect_timeout)
                if self.ib.isConnected():
                    self.connected = True
                    self.state = ConnState.CONNECTED
                    self.current_client_id = cid
                    self.last_error = None
                    # small probe
                    try:
                        self.ib.reqCurrentTime()
                    except Exception as pe:
                        self.state = ConnState.DEGRADED
                        log.warning(f"Connection degraded: {pe}")
                    log.info(f"Connected on clientId {cid}")
                    return True
            except Exception as e:
                es = str(e)
                self.last_error = es
                log.warning(f"Connect attempt {i+1}/{self.cfg.max_retries} failed: {es}")
                if "326" in es:
                    # clientId in use -> try next cid quickly
                    continue
                time.sleep(self.cfg.retry_delay)

        self.connected = False
        self.state = ConnState.FAILED
        return False

    def disconnect(self):
        try:
            if self.ib and self.ib.isConnected():
                self.ib.disconnect()
        except Exception as e:
            log.warning(f"disconnect error: {e}")
        self.connected = False
        self.state = ConnState.DISCONNECTED
        self.ib = None

    def get_detailed_status(self) -> Dict[str, Any]:
        return {
            "connected": self.connected,
            "state": self.state,
            "host": self.cfg.host,
            "port": self.cfg.port,
            "current_client_id": self.current_client_id,
            "base_client_id": self.cfg.client_id,
            "attempts": self.attempts,
            "last_error": self.last_error,
            "read_only": self.cfg.read_only,
            "ib_available": _IB_OK,
        }

    # simple helpers
    def _contract(self, symbol: str):
        return Stock(symbol.upper(), "SMART", "USD")

    def preview_order(self, symbol: str, side: str, qty: int, limitPrice: float | None = None):
        if not self.connected or not self.ib:
            raise RuntimeError("IB not connected")
        orderSide = "BUY" if side.upper() == "BUY" else "SELL"
        order = LimitOrder(orderSide, int(qty), limitPrice) if limitPrice is not None else MarketOrder(orderSide, int(qty))
        try:
            prev = self.ib.whatIfOrder(self._contract(symbol), order)
            return {
                "ok": True,
                "symbol": symbol.upper(),
                "side": orderSide,
                "qty": int(qty),
                "limitPrice": limitPrice,
                "estimatedCommission": getattr(prev, "commission", None),
                "initialMarginChange": getattr(prev, "initMarginChange", None),
                "maintenanceMarginChange": getattr(prev, "maintMarginChange", None),
                "equityWithLoanChange": getattr(prev, "equityWithLoanChange", None),
                "warningText": getattr(prev, "warningText", None),
            }
        except Exception as e:
            return {"ok": False, "error": str(e)}

    def place_order(self, symbol: str, side: str, qty: int, limitPrice: float | None = None):
        if self.cfg.read_only:
            raise PermissionError("read_only mode; refusing to place live order")
        if not self.connected or not self.ib:
            raise RuntimeError("IB not connected")
        orderSide = "BUY" if side.upper() == "BUY" else "SELL"
        order = LimitOrder(orderSide, int(qty), limitPrice) if limitPrice is not None else MarketOrder(orderSide, int(qty))
        trade = self.ib.placeOrder(self._contract(symbol), order)
        t0 = time.time()
        while trade.order.orderId is None and time.time() - t0 < 2.0:
            self.ib.waitOnUpdate(timeout=0.2)
        return {
            "ok": True,
            "orderId": getattr(trade.order, "orderId", None),
            "status": getattr(trade.orderStatus, "status", "submitted"),
        }

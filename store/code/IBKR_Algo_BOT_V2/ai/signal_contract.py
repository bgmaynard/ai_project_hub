"""
Signal Contract Schema
======================
Immutable signal definitions generated by Qlib offline research.

ARCHITECTURAL PRINCIPLE:
- SignalContracts are generated OFFLINE by Qlib research
- They define WHAT signals are valid for trading
- Execution can ONLY act on approved SignalContracts
- Chronos provides context but CANNOT create/modify contracts

Key Concepts:
- A SignalContract is a pre-approved trading signal template
- It specifies: symbol, direction, valid regimes, required confidence
- Generated from backtested, validated Qlib research
- NEVER created during live trading
"""

from dataclasses import dataclass, field, asdict
from datetime import datetime, timedelta
from typing import List, Dict, Optional, Any
from enum import Enum
import json
import uuid
import logging

logger = logging.getLogger(__name__)


class SignalDirection(Enum):
    """Trade direction"""
    LONG = "LONG"
    SHORT = "SHORT"


class SignalHorizon(Enum):
    """Trade horizon timeframe"""
    SCALP = "SCALP"          # < 5 minutes
    INTRADAY = "INTRADAY"    # Same day
    SWING = "SWING"          # 1-5 days
    POSITION = "POSITION"    # 5+ days


class MarketRegime(Enum):
    """Market regime classification (from Chronos)"""
    TRENDING_UP = "TRENDING_UP"
    TRENDING_DOWN = "TRENDING_DOWN"
    RANGING = "RANGING"
    VOLATILE = "VOLATILE"
    UNKNOWN = "UNKNOWN"


class VetoReason(Enum):
    """Reasons a signal can be vetoed"""
    REGIME_MISMATCH = "REGIME_MISMATCH"           # Current regime not in valid_regimes
    CONFIDENCE_LOW = "CONFIDENCE_LOW"              # Chronos confidence below threshold
    RISK_LIMIT_EXCEEDED = "RISK_LIMIT_EXCEEDED"   # Would exceed risk limits
    DRAWDOWN_EXCEEDED = "DRAWDOWN_EXCEEDED"       # Max drawdown already hit
    CONTRACT_EXPIRED = "CONTRACT_EXPIRED"          # Signal contract has expired
    COOLDOWN_ACTIVE = "COOLDOWN_ACTIVE"           # Symbol on cooldown
    MARKET_CLOSED = "MARKET_CLOSED"               # Market not open
    BLACKLISTED = "BLACKLISTED"                   # Symbol is blacklisted
    INVALID_REGIME = "INVALID_REGIME"             # Regime explicitly invalid for signal


@dataclass
class SignalContract:
    """
    Immutable signal definition - the core trading primitive.

    Generated OFFLINE by Qlib research. Defines conditions under which
    a trade is valid. Execution MUST check a signal against its contract
    before acting.

    IMPORTANT: SignalContracts are NEVER created during live trading.
    They are exported from Qlib backtests as pre-approved signal templates.
    """
    # Identity
    signal_id: str = field(default_factory=lambda: str(uuid.uuid4()))

    # What to trade
    symbol: str = ""
    direction: str = "LONG"  # LONG | SHORT

    # When to trade
    horizon: str = "SCALP"  # SCALP | INTRADAY | SWING | POSITION

    # Features that triggered this signal in research
    features: List[str] = field(default_factory=list)

    # Confidence requirements (checked against Chronos output)
    confidence_required: float = 0.55  # Minimum confidence to execute

    # Regime constraints (validated against Chronos regime)
    valid_regimes: List[str] = field(default_factory=lambda: ["TRENDING_UP", "RANGING"])
    invalid_regimes: List[str] = field(default_factory=lambda: ["VOLATILE"])

    # Risk constraints
    max_drawdown_allowed: float = 0.03  # 3% max drawdown
    max_position_pct: float = 0.02      # 2% of portfolio

    # Expected performance (from backtest)
    expected_return: float = 0.02       # 2% expected return
    historical_win_rate: float = 0.55   # 55% win rate in backtest
    profit_factor: float = 1.5          # Backtest profit factor

    # Metadata
    source: str = "QLIB"  # Always QLIB for offline signals
    created_at: str = field(default_factory=lambda: datetime.now().isoformat())
    expires_at: str = field(default_factory=lambda: (datetime.now() + timedelta(days=30)).isoformat())

    # Research context
    backtest_period: str = ""           # e.g., "2024-01-01 to 2024-12-01"
    sample_size: int = 0                # Number of trades in backtest
    sharpe_ratio: float = 0.0           # Backtest Sharpe ratio

    def is_expired(self) -> bool:
        """Check if this signal contract has expired."""
        try:
            expiry = datetime.fromisoformat(self.expires_at)
            return datetime.now() > expiry
        except:
            return False

    def is_regime_valid(self, current_regime: str) -> bool:
        """Check if current market regime is valid for this signal."""
        if current_regime in self.invalid_regimes:
            return False
        if self.valid_regimes and current_regime not in self.valid_regimes:
            return False
        return True

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary."""
        return asdict(self)

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'SignalContract':
        """Create from dictionary."""
        return cls(**data)

    def __str__(self) -> str:
        return (
            f"SignalContract({self.symbol} {self.direction} {self.horizon} | "
            f"conf>={self.confidence_required:.0%} | "
            f"regimes={self.valid_regimes} | "
            f"exp_ret={self.expected_return:.1%})"
        )


@dataclass
class GateResult:
    """
    Result of signal gating decision.

    Every trade attempt MUST be gated. This provides full audit trail
    of why signals were approved or vetoed.
    """
    signal_id: str
    symbol: str
    approved: bool

    # Context at decision time
    current_regime: str = ""
    chronos_confidence: float = 0.0

    # Veto information (if not approved)
    veto_reason: Optional[str] = None
    veto_details: str = ""

    # Contract requirements vs actual
    required_confidence: float = 0.0
    required_regimes: List[str] = field(default_factory=list)

    # Micro-momentum override info (Task D)
    override_applied: bool = False
    override_reason: Optional[str] = None
    override_size_multiplier: float = 1.0

    # Timestamp
    gated_at: str = field(default_factory=lambda: datetime.now().isoformat())

    def to_dict(self) -> Dict[str, Any]:
        return asdict(self)

    def log_entry(self) -> str:
        """Generate log entry for this gate result."""
        status = "APPROVED" if self.approved else f"VETOED ({self.veto_reason})"
        override_info = ""
        if self.override_applied:
            override_info = f" | MICRO_OVERRIDE (size_mult={self.override_size_multiplier})"
        return (
            f"[GATE] {self.symbol} | {status}{override_info} | "
            f"regime={self.current_regime} | conf={self.chronos_confidence:.2%} | "
            f"{self.veto_details}"
        )


@dataclass
class ChronosContext:
    """
    Market context from Chronos.

    IMPORTANT: Chronos ONLY provides context - it does NOT make trading decisions.
    This context is used by the Gating Engine to validate SignalContracts.

    TASK 3: Regime Reconciliation
    - macro_regime: SPY/market-level assessment (overall market conditions)
    - micro_regime: Symbol-specific assessment (individual stock behavior)
    - market_regime: Legacy field, now defaults to micro_regime
    """
    # =========================================================================
    # TASK 3: Split regime into MACRO (market) and MICRO (symbol)
    # =========================================================================
    # Macro regime - from SPY/QQQ market-level analysis
    macro_regime: str = "UNKNOWN"
    macro_confidence: float = 0.0

    # Micro regime - symbol-specific analysis
    micro_regime: str = "UNKNOWN"
    micro_confidence: float = 0.0

    # Legacy field - for backwards compatibility, defaults to micro_regime
    market_regime: str = "UNKNOWN"
    regime_confidence: float = 0.0

    # TASK 3: Override settings
    # Strong micro signals can override cautious macro regimes
    micro_override_threshold: float = 0.75  # Micro confidence required for override
    macro_blocklist: List[str] = field(default_factory=lambda: ["TRENDING_DOWN"])  # Macro regimes that NEVER allow override

    # Probabilistic forecast (informational only)
    prob_up: float = 0.5
    prob_down: float = 0.5
    expected_return_5d: float = 0.0

    # Volatility context
    current_volatility: float = 0.0
    volatility_percentile: float = 0.5  # 0-1, where in historical range

    # Trend context
    trend_strength: float = 0.0  # 0-1
    trend_direction: int = 0     # -1, 0, 1

    # Timestamp
    computed_at: str = field(default_factory=lambda: datetime.now().isoformat())

    # TASK 3: Helper methods for regime reconciliation
    def get_effective_regime(self) -> str:
        """
        Get effective regime after reconciliation.

        Logic:
        1. If macro is in blocklist (TRENDING_DOWN), use macro (never override)
        2. If micro confidence >= threshold, use micro (override allowed)
        3. Otherwise, use macro (cautious default)
        """
        # Never override hard bearish macro
        if self.macro_regime in self.macro_blocklist:
            return self.macro_regime

        # Strong micro signal can override cautious macro
        if self.micro_confidence >= self.micro_override_threshold:
            return self.micro_regime

        # Default to macro (cautious)
        return self.macro_regime

    def get_regime_decision_explanation(self) -> str:
        """Explain why the effective regime was chosen."""
        if self.macro_regime in self.macro_blocklist:
            return f"Using MACRO={self.macro_regime} (in blocklist, never override)"
        if self.micro_confidence >= self.micro_override_threshold:
            return f"Using MICRO={self.micro_regime} (confidence {self.micro_confidence:.0%} >= {self.micro_override_threshold:.0%} threshold)"
        return f"Using MACRO={self.macro_regime} (micro confidence {self.micro_confidence:.0%} < {self.micro_override_threshold:.0%})"

    def to_dict(self) -> Dict[str, Any]:
        return asdict(self)


@dataclass
class RiskState:
    """
    Current risk state for risk-based gating.
    """
    # Portfolio state
    current_drawdown: float = 0.0       # Current drawdown from peak
    daily_pnl: float = 0.0              # Today's P&L
    max_daily_loss: float = 200.0       # Max allowed daily loss

    # Position limits
    open_positions: int = 0
    max_positions: int = 3

    # Symbol-level state
    symbol_cooldowns: Dict[str, str] = field(default_factory=dict)  # symbol -> cooldown_until

    # Trade counts
    daily_trades: int = 0
    max_daily_trades: int = 100

    def is_symbol_on_cooldown(self, symbol: str) -> bool:
        """Check if symbol is on cooldown."""
        if symbol not in self.symbol_cooldowns:
            return False
        try:
            cooldown_until = datetime.fromisoformat(self.symbol_cooldowns[symbol])
            return datetime.now() < cooldown_until
        except:
            return False

    def violates_limits(self, contract: SignalContract) -> tuple[bool, str]:
        """
        Check if executing this signal would violate risk limits.

        Returns: (violates, reason)
        """
        # Check daily loss limit
        if self.daily_pnl < -self.max_daily_loss:
            return True, f"Daily loss limit exceeded (${self.daily_pnl:.2f})"

        # Check position limit
        if self.open_positions >= self.max_positions:
            return True, f"Max positions reached ({self.open_positions}/{self.max_positions})"

        # Check trade limit
        if self.daily_trades >= self.max_daily_trades:
            return True, f"Max daily trades reached ({self.daily_trades}/{self.max_daily_trades})"

        # Check drawdown vs contract's max allowed
        if self.current_drawdown > contract.max_drawdown_allowed:
            return True, f"Drawdown {self.current_drawdown:.1%} > contract max {contract.max_drawdown_allowed:.1%}"

        return False, ""

    def to_dict(self) -> Dict[str, Any]:
        return asdict(self)


# Signal Contract Repository
class SignalContractRepository:
    """
    Repository for managing SignalContracts.

    Contracts are loaded from disk (exported by Qlib offline).
    NEVER generates new contracts during runtime.
    """

    def __init__(self, contracts_path: str = None):
        self.contracts: Dict[str, SignalContract] = {}  # signal_id -> contract
        self.by_symbol: Dict[str, List[str]] = {}        # symbol -> [signal_ids]
        self.contracts_path = contracts_path or "ai/signal_contracts.json"

    def load(self) -> int:
        """
        Load contracts from disk.
        Returns number of contracts loaded.
        """
        try:
            with open(self.contracts_path, 'r') as f:
                data = json.load(f)

            for item in data.get('contracts', []):
                contract = SignalContract.from_dict(item)
                self.add(contract)

            logger.info(f"Loaded {len(self.contracts)} signal contracts")
            return len(self.contracts)

        except FileNotFoundError:
            logger.warning(f"No contracts file found at {self.contracts_path}")
            return 0
        except Exception as e:
            logger.error(f"Failed to load contracts: {e}")
            return 0

    def save(self):
        """Save contracts to disk."""
        data = {
            'contracts': [c.to_dict() for c in self.contracts.values()],
            'exported_at': datetime.now().isoformat(),
            'count': len(self.contracts)
        }

        with open(self.contracts_path, 'w') as f:
            json.dump(data, f, indent=2)

        logger.info(f"Saved {len(self.contracts)} contracts to {self.contracts_path}")

    def add(self, contract: SignalContract):
        """Add a contract to the repository."""
        self.contracts[contract.signal_id] = contract

        if contract.symbol not in self.by_symbol:
            self.by_symbol[contract.symbol] = []
        self.by_symbol[contract.symbol].append(contract.signal_id)

    def get(self, signal_id: str) -> Optional[SignalContract]:
        """Get a contract by ID."""
        return self.contracts.get(signal_id)

    def get_for_symbol(self, symbol: str) -> List[SignalContract]:
        """Get all contracts for a symbol."""
        signal_ids = self.by_symbol.get(symbol, [])
        return [self.contracts[sid] for sid in signal_ids if sid in self.contracts]

    def get_active(self) -> List[SignalContract]:
        """Get all non-expired contracts."""
        return [c for c in self.contracts.values() if not c.is_expired()]

    def prune_expired(self) -> int:
        """Remove expired contracts. Returns count removed."""
        expired = [sid for sid, c in self.contracts.items() if c.is_expired()]
        for sid in expired:
            del self.contracts[sid]

        # Rebuild by_symbol index
        self.by_symbol = {}
        for c in self.contracts.values():
            if c.symbol not in self.by_symbol:
                self.by_symbol[c.symbol] = []
            self.by_symbol[c.symbol].append(c.signal_id)

        return len(expired)


# Singleton repository
_contract_repository: Optional[SignalContractRepository] = None


def get_contract_repository() -> SignalContractRepository:
    """Get the global contract repository."""
    global _contract_repository
    if _contract_repository is None:
        _contract_repository = SignalContractRepository()
        _contract_repository.load()
    return _contract_repository


if __name__ == "__main__":
    # Example: Create a sample contract
    logging.basicConfig(level=logging.INFO)

    contract = SignalContract(
        symbol="AAPL",
        direction="LONG",
        horizon="SCALP",
        features=["RSI_oversold", "MACD_crossover", "volume_surge"],
        confidence_required=0.55,
        valid_regimes=["TRENDING_UP", "RANGING"],
        invalid_regimes=["VOLATILE", "TRENDING_DOWN"],
        max_drawdown_allowed=0.03,
        expected_return=0.02,
        historical_win_rate=0.58,
        profit_factor=1.6,
        backtest_period="2024-01-01 to 2024-12-01",
        sample_size=150,
        sharpe_ratio=1.2
    )

    print("Sample SignalContract:")
    print(contract)
    print("\nAs dict:")
    print(json.dumps(contract.to_dict(), indent=2))
